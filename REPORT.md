# Backtracker Report

*Author: Christopher Myers (crmyers)*

## Performance

The program is able to easily solve all of the basic input list, except #25 which is unsolvable. It does take a while
to determine if a problem is unsolvable, but that's only to be expected considering the nature of backtracking searches.
It does appear to struggle with the "hard" examples given (at the time of this writing I'm running it on hard4 and it
hasn't found a solution in about 20 minutes).

To analyze the difference between forward checking only and all heuristics (it's technically impossible to disable
all forward checking in this implementation), I wrote a script that tested on inputs 1-23 (25 is impossible, 26 and
24 take forever to run without heuristics) 5 times with heuristics enabled, 5 times without, then output the results
to files (data.csv and data2.csv).

I ran a paired, 2-tailed t-test on the data and obtained p=0.36 for the first and p=0.34 for the second, suggesting that
the differences here are *not* statistically significant. However, this is also with the two hardest cases removed, and
"dumb" mode with no heuristics is much, much more vulnerable to taking thousands of milliseconds to compute, whereas
with heuristics everything is calculated in under a second. All things considered, I still believe that running with
heuristics is more optimal than running without.

## Design Overview
### Data structures

The state of the work-in-progress solution is referred to as the *universe*, and is a Python dictionary (hashmap)
that maps bags to a list of their contents. This is in contrast to a typical CSP array of variables, but it helps
simplify many of the constraint functions.

Since Python treats functions as first-class objects, **I modeled constraints as functions**. Each function accepts
a map of bags to their capacities, variables to their weights, and finally the universe that should be evaluated.
Except for the base constraints of no-overfilling and 90% capacity, constraint functions are generated by
constraint creation functions, which supply appropriate data for the constraints and set a variable on the function
(Python allows functions to own variables, sort of like a static variable) that contains a list of variables involved
in that constraint. 

Constraint functions return a boolean value, `True` if there was no conflict and `False` otherwise. Some return true
in case of partial satisfaction because if they returned false it would preclude valid solutions. For instance, if the
fitting limit constraint detects that not all variables have been assigned yet, it only checks if the maximum has been
exceeded, because otherwise a fit limit with a minimum of 2 or higher would prevent *any* variables from being assigned
bags.

### File parsing

The program simply iterates over the lines in the file, incrementing its section counter by 1 ever time it encounters
the section delineation marker. The section counter determines what constraint creation function the parser calls
for each line. The generated constraint functions are added to a constraints list.

### Move generation

A function `get_valid_moves` in `csp_utils.py` is used to generate a list possible "moves" (new variable assignments)
that don't violate any of the constraints. This helps reduce the search space and is one part of my **forward checking
implementation**.

The function works by iterating over each variable that has not yet been assigned, assigning it a bag in a new
hypothetical universe, and running all the constraints in the constraints list against it. If any one fails, the
assignment is rejected.

### Backtracking

The backtracking algorithm first calls into `get_valid_moves` to get a list of possible moves that it correlates
with the variable being assigned. In the naive case with no heuristics, it would use this list alone for backtracking,
but instead it performs different sorts and expansions.

**Minimum remaining heuristic** Variables are first grouped by the number of possible assignments they have in the moves
list. E.g. if A has (A=2, A=5), B has (B=3), and C has (C=1, C=2), the grouping will look something like
{2: [A, C], 1: [B]}.

**Degree heuristic (most constrained)** Each sublist of variables is sorted by the number of constraints that apply
to each, with more constraints having higher precedence. The list of variables is then put back together into a one level
list. So, if A had 1 constraint and C had 2, you would first get {2: [C, A], 1: [B]} and then [B, C, A] for the final
ordering.

**Least constraining value + forward checking** Now that we know what variable to inspect first, the program expands
that value by applying all its applicable moves to generate alternate universes. It then generates a set of valid
moves *within* those alternate universes and sorts each variable's list of values by the number of possible moves
in the subsequent list of valid moves. This is the second part of my forward checking implementation.

**Recursion** By this point the program now has a list of alternate universes, sorted in accordance with minimum
remaining, degree, and least constraining value heuristics. It iterates over each one in order and calls into itself,
passing in the generated alternate universe plus the corresponding list of moves -- this saves CPU time since we don't
have to recalculate them.

**End checking** If the algorithm gets an empty moves list, it checks the final two constraints -- 90% filled and all
variables assigned (these are set aside because they will almost always fail on a partial solution). If those pass,
the algorithm returns the current universe, which is propagated back up the call stack. Otherwise it returns `None`.
signifying backtracking.


## Pseudocode for backtracking:

    backtrack(universe, possible moves):
        Get a list of valid moves M from the universe, or use possible moves if given
        
        If list of moves is empty:
            If all variables assigned and 90% fill satisfied:
                Return the universe
            Return null
        
        Count the instances of variable assignments, group variables by appearance count
        Sort each sublist of variables by the number of constraints
        Concatenate into one big list
        
        Expand variable assignments into alternate universes
        For each variable, sort alternate universes by count of possible moves for each 
        Concatenate into one big list of alternate universes
        
        For each alternate universe:
            backtrack(alternate universe, possible moves for alternate universe)
    